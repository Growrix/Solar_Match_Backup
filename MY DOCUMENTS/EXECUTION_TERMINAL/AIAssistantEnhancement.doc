# AI ASSISTANT ENHANCEMENT - DEVELOPER EXECUTION SCRIPT
**Generated:** August 4, 2025  
**Priority:** MEDIUM - EXECUTE AFTER QUOTE VERSIONING  
**Dependencies:** QuoteVersioningSystem.doc must be 100% complete

---

## üìã EXECUTION OVERVIEW

**Objective:** Enhance existing AI assistant with advanced solar knowledge and integrated workflows
**Estimated Time:** 2-3 days
**Risk Level:** MEDIUM (AI API integration complexity)

**DEVELOPER ACTIONS:** This script will guide you to:
1. Enhance AI service with solar-specific knowledge
2. Implement context-aware conversations
3. Build solar calculation and analysis tools
4. Create AI-powered quote optimization
5. Test AI integration with platform workflows

---

## üéØ AI ASSISTANT REQUIREMENTS

**Current State Analysis:**
- Basic DeepSeek API integration exists in `hooks/useDeepseekAPI.ts`
- Chat functionality present but limited
- No solar-specific knowledge base
- Missing workflow integration

**Enhanced Features Needed:**
- ‚úÖ Solar system sizing calculator
- ‚úÖ Rebate and incentive guidance
- ‚úÖ Equipment recommendations
- ‚úÖ Quote analysis and optimization
- ‚úÖ Installation timeline estimation
- ‚úÖ ROI calculations
- ‚úÖ Integrated chat with context awareness

---

## üîß EXECUTION STEPS

### STEP 1: Enhanced AI Service Implementation
**Timeline:** Day 1 Full Day
**Files:** `lib/services/aiAssistantService.ts`

```typescript
// lib/services/aiAssistantService.ts
import { createClient } from '@/lib/supabase'
import type { SolarQuote, QuoteVersion } from '@/types/database.types'

export interface AIContext {
  userType: 'homeowner' | 'installer' | 'admin'
  userId: string
  currentQuote?: SolarQuote
  currentVersion?: QuoteVersion
  location?: {
    state: string
    postcode: string
    latitude?: number
    longitude?: number
  }
  propertyDetails?: {
    roofType: string
    roofArea: number
    shadingFactors: string[]
    energyUsage: number
  }
}

export interface AIResponse {
  message: string
  type: 'text' | 'calculation' | 'recommendation' | 'analysis'
  data?: any
  actions?: {
    label: string
    action: string
    parameters?: Record<string, any>
  }[]
  followUp?: string[]
}

export class AIAssistantService {
  private supabase = createClient()
  private baseUrl = 'https://api.deepseek.com/v1/chat/completions'
  private apiKey = process.env.DEEPSEEK_API_KEY

  /**
   * Enhanced chat with solar expertise
   */
  async chat(
    message: string,
    context: AIContext,
    conversationHistory: { role: 'user' | 'assistant'; content: string }[] = []
  ): Promise<AIResponse> {
    try {
      const systemPrompt = this.buildSystemPrompt(context)
      const enhancedMessage = await this.enhanceUserMessage(message, context)

      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          model: 'deepseek-chat',
          messages: [
            { role: 'system', content: systemPrompt },
            ...conversationHistory,
            { role: 'user', content: enhancedMessage },
          ],
          temperature: 0.3,
          max_tokens: 1000,
        }),
      })

      if (!response.ok) {
        throw new Error('AI service unavailable')
      }

      const data = await response.json()
      const aiMessage = data.choices[0].message.content

      return this.parseAIResponse(aiMessage, context)
    } catch (error) {
      console.error('AI chat error:', error)
      return {
        message: "I'm having trouble connecting right now. Please try again later.",
        type: 'text',
      }
    }
  }

  /**
   * Calculate optimal system size
   */
  async calculateSystemSize(
    energyUsage: number,
    location: { state: string; postcode: string },
    roofSpace: number,
    budget?: number
  ): Promise<AIResponse> {
    try {
      // Get solar irradiance data for location
      const solarData = await this.getSolarIrradiance(location)
      
      // Calculate system size
      const dailyUsage = energyUsage / 365 // Convert annual to daily
      const peakSunHours = solarData.peakSunHours
      const systemEfficiency = 0.85 // Account for losses
      
      const requiredCapacity = (dailyUsage / peakSunHours) / systemEfficiency
      const maxCapacityByRoof = roofSpace / 20 // Rough estimate: 20m¬≤ per kW
      
      const recommendedSize = Math.min(requiredCapacity, maxCapacityByRoof)
      const roundedSize = Math.round(recommendedSize * 2) / 2 // Round to nearest 0.5kW

      // Cost estimation
      const avgCostPerKw = 2500 // AUD per kW installed
      const estimatedCost = roundedSize * avgCostPerKw

      // Savings calculation
      const annualGeneration = roundedSize * peakSunHours * 365 * systemEfficiency
      const electricityRate = 0.28 // AUD per kWh
      const annualSavings = annualGeneration * electricityRate
      const paybackPeriod = estimatedCost / annualSavings

      return {
        message: `Based on your energy usage of ${energyUsage}kWh/year and available roof space, I recommend a ${roundedSize}kW solar system.`,
        type: 'calculation',
        data: {
          recommendedSize: roundedSize,
          estimatedCost,
          annualGeneration: Math.round(annualGeneration),
          annualSavings: Math.round(annualSavings),
          paybackPeriod: Math.round(paybackPeriod * 10) / 10,
          location: location.state,
          peakSunHours,
        },
        actions: [
          {
            label: 'Get Quotes',
            action: 'create_quote',
            parameters: { systemSize: roundedSize },
          },
          {
            label: 'Refine Calculation',
            action: 'refine_sizing',
          },
        ],
        followUp: [
          'Would you like to see equipment recommendations?',
          'Should I check available rebates for your area?',
          'Do you want to explore battery storage options?',
        ],
      }
    } catch (error) {
      console.error('System sizing error:', error)
      return {
        message: 'I had trouble calculating the optimal system size. Please provide your location and energy usage details.',
        type: 'text',
      }
    }
  }

  /**
   * Analyze quote and provide recommendations
   */
  async analyzeQuote(quote: SolarQuote, versions?: QuoteVersion[]): Promise<AIResponse> {
    try {
      const currentVersion = versions?.find(v => v.is_current) || null
      
      if (!currentVersion) {
        return {
          message: 'No quote version available for analysis.',
          type: 'text',
        }
      }

      const analysis = {
        pricePerKw: currentVersion.total_cost_cents / 100 / currentVersion.system_size_kw,
        systemSizeRating: this.rateSystemSize(currentVersion.system_size_kw, quote.annual_usage || 0),
        equipmentQuality: this.rateEquipment(currentVersion.panel_brand, currentVersion.inverter_brand),
        warrantyRating: this.rateWarranty(currentVersion.warranty_years || 10),
        valueRating: this.calculateValueRating(currentVersion),
      }

      const marketAverage = 2500 // Average cost per kW in AUD
      const priceComparison = analysis.pricePerKw > marketAverage ? 'above' : 'below'
      const priceDifference = Math.abs(analysis.pricePerKw - marketAverage)

      let message = `Quote Analysis for ${currentVersion.system_size_kw}kW System:\n\n`
      message += `üí∞ Price: $${Math.round(analysis.pricePerKw)}/kW (${priceComparison} market average by $${Math.round(priceDifference)})\n`
      message += `‚ö° System Size: ${analysis.systemSizeRating.rating}/5 - ${analysis.systemSizeRating.comment}\n`
      message += `üîß Equipment: ${analysis.equipmentQuality.rating}/5 - ${analysis.equipmentQuality.comment}\n`
      message += `üõ°Ô∏è Warranty: ${analysis.warrantyRating.rating}/5 - ${analysis.warrantyRating.comment}\n`
      message += `üìä Overall Value: ${analysis.valueRating.rating}/5`

      const actions = []
      if (analysis.valueRating.rating < 4) {
        actions.push({
          label: 'Request Revision',
          action: 'request_revision',
          parameters: { suggestions: analysis.valueRating.suggestions },
        })
      }
      
      actions.push({
        label: 'Compare Quotes',
        action: 'compare_quotes',
      })

      return {
        message,
        type: 'analysis',
        data: analysis,
        actions,
        followUp: [
          'Would you like me to explain any part of this analysis?',
          'Should I help you negotiate better terms?',
          'Do you want to see similar quotes in your area?',
        ],
      }
    } catch (error) {
      console.error('Quote analysis error:', error)
      return {
        message: 'I had trouble analyzing this quote. Please ensure all quote details are available.',
        type: 'text',
      }
    }
  }

  /**
   * Get rebates and incentives information
   */
  async getRebatesInfo(location: { state: string; postcode: string }): Promise<AIResponse> {
    try {
      const rebates = await this.fetchRebateData(location)
      
      let message = `Solar Rebates & Incentives for ${location.state}:\n\n`
      
      rebates.forEach((rebate, index) => {
        message += `${index + 1}. ${rebate.name}\n`
        message += `   üí∞ Value: ${rebate.value}\n`
        message += `   üìã Requirements: ${rebate.requirements}\n`
        message += `   ‚è∞ Deadline: ${rebate.deadline}\n\n`
      })

      return {
        message,
        type: 'recommendation',
        data: { rebates, totalValue: rebates.reduce((sum, r) => sum + r.amount, 0) },
        actions: [
          {
            label: 'Apply for Rebates',
            action: 'apply_rebates',
          },
          {
            label: 'Calculate Savings',
            action: 'calculate_savings',
          },
        ],
        followUp: [
          'Would you like help with rebate applications?',
          'Should I factor these into your quote analysis?',
        ],
      }
    } catch (error) {
      console.error('Rebates info error:', error)
      return {
        message: 'I had trouble fetching rebate information. Please check back later or contact your installer.',
        type: 'text',
      }
    }
  }

  /**
   * Equipment recommendations
   */
  async recommendEquipment(
    systemSize: number,
    budget: number,
    preferences: {
      quality: 'budget' | 'premium' | 'tier1'
      features: string[]
    }
  ): Promise<AIResponse> {
    try {
      const recommendations = await this.getEquipmentRecommendations(systemSize, budget, preferences)
      
      let message = `Equipment Recommendations for ${systemSize}kW System:\n\n`
      
      recommendations.panels.forEach((panel, index) => {
        message += `Panel Option ${index + 1}: ${panel.brand} ${panel.model}\n`
        message += `  ‚Ä¢ Efficiency: ${panel.efficiency}%\n`
        message += `  ‚Ä¢ Warranty: ${panel.warranty} years\n`
        message += `  ‚Ä¢ Price: $${panel.pricePerPanel} per panel\n\n`
      })

      recommendations.inverters.forEach((inverter, index) => {
        message += `Inverter Option ${index + 1}: ${inverter.brand} ${inverter.model}\n`
        message += `  ‚Ä¢ Type: ${inverter.type}\n`
        message += `  ‚Ä¢ Efficiency: ${inverter.efficiency}%\n`
        message += `  ‚Ä¢ Warranty: ${inverter.warranty} years\n\n`
      })

      return {
        message,
        type: 'recommendation',
        data: recommendations,
        actions: [
          {
            label: 'Get Quotes with This Equipment',
            action: 'request_quotes',
            parameters: { equipment: recommendations },
          },
          {
            label: 'Compare Equipment',
            action: 'compare_equipment',
          },
        ],
        followUp: [
          'Would you like to see battery storage options?',
          'Should I explain the differences between these options?',
        ],
      }
    } catch (error) {
      console.error('Equipment recommendation error:', error)
      return {
        message: 'I had trouble generating equipment recommendations. Please specify your system size and budget.',
        type: 'text',
      }
    }
  }

  /**
   * Build context-aware system prompt
   */
  private buildSystemPrompt(context: AIContext): string {
    let prompt = `You are SolarMatch AI, an expert solar energy assistant helping ${context.userType}s in Australia. `
    
    prompt += `You have deep knowledge of:
    - Solar system sizing and design
    - Australian solar rebates and incentives
    - Equipment specifications and recommendations
    - Installation processes and timelines
    - ROI calculations and financing options
    - Local regulations and standards
    
    Always provide accurate, helpful information specific to Australian conditions and regulations.
    Use metric units and Australian dollar amounts.
    Be conversational but professional.
    If you cannot provide specific information, explain what additional details you need.`

    if (context.location) {
      prompt += `\n\nUser location: ${context.location.state}, ${context.location.postcode}`
    }

    if (context.currentQuote) {
      prompt += `\n\nCurrent quote context: ${context.currentQuote.system_size}kW system, ${context.currentQuote.property_address}`
    }

    return prompt
  }

  /**
   * Enhance user message with context
   */
  private async enhanceUserMessage(message: string, context: AIContext): Promise<string> {
    let enhanced = message

    // Add context if relevant keywords detected
    if (this.containsSizingKeywords(message) && context.currentQuote) {
      enhanced += `\n\nContext: User has a quote for ${context.currentQuote.system_size}kW system`
      
      if (context.currentQuote.annual_usage) {
        enhanced += ` with annual usage of ${context.currentQuote.annual_usage}kWh`
      }
    }

    return enhanced
  }

  /**
   * Parse AI response and structure it
   */
  private parseAIResponse(response: string, context: AIContext): AIResponse {
    // Look for structured responses or calculations
    if (response.includes('System Size:') || response.includes('kW')) {
      return {
        message: response,
        type: 'calculation',
        followUp: [
          'Would you like me to find installers for this system size?',
          'Should I calculate potential savings?',
        ],
      }
    }

    if (response.includes('Rebate') || response.includes('Incentive')) {
      return {
        message: response,
        type: 'recommendation',
        actions: [
          {
            label: 'Learn More About Rebates',
            action: 'show_rebates',
          },
        ],
      }
    }

    return {
      message: response,
      type: 'text',
    }
  }

  /**
   * Helper methods for analysis
   */
  private rateSystemSize(systemSize: number, annualUsage: number) {
    if (!annualUsage) return { rating: 3, comment: 'Unable to assess without usage data' }
    
    const optimalSize = annualUsage / 1500 // Rough calculation
    const ratio = systemSize / optimalSize
    
    if (ratio < 0.7) return { rating: 2, comment: 'System may be undersized' }
    if (ratio > 1.3) return { rating: 2, comment: 'System may be oversized' }
    if (ratio > 0.9 && ratio < 1.1) return { rating: 5, comment: 'Excellent sizing' }
    return { rating: 4, comment: 'Good sizing' }
  }

  private rateEquipment(panelBrand?: string, inverterBrand?: string) {
    const tier1Panels = ['SunPower', 'LG', 'Panasonic', 'REC', 'Jinko']
    const tier1Inverters = ['SMA', 'Fronius', 'SolarEdge', 'Enphase']
    
    let rating = 3
    let comment = 'Standard equipment'
    
    if (panelBrand && tier1Panels.includes(panelBrand)) rating += 1
    if (inverterBrand && tier1Inverters.includes(inverterBrand)) rating += 1
    
    if (rating >= 5) comment = 'Premium equipment selection'
    else if (rating >= 4) comment = 'High-quality equipment'
    
    return { rating: Math.min(rating, 5), comment }
  }

  private rateWarranty(warrantyYears: number) {
    if (warrantyYears >= 25) return { rating: 5, comment: 'Excellent warranty coverage' }
    if (warrantyYears >= 20) return { rating: 4, comment: 'Good warranty coverage' }
    if (warrantyYears >= 15) return { rating: 3, comment: 'Standard warranty' }
    if (warrantyYears >= 10) return { rating: 2, comment: 'Basic warranty' }
    return { rating: 1, comment: 'Limited warranty coverage' }
  }

  private calculateValueRating(version: QuoteVersion) {
    const pricePerKw = version.total_cost_cents / 100 / version.system_size_kw
    const marketAverage = 2500
    
    let rating = 3
    const suggestions = []
    
    if (pricePerKw > marketAverage * 1.2) {
      rating -= 2
      suggestions.push('Price is significantly above market average')
    } else if (pricePerKw > marketAverage * 1.1) {
      rating -= 1
      suggestions.push('Price is above market average')
    } else if (pricePerKw < marketAverage * 0.9) {
      rating += 1
      suggestions.push('Competitive pricing')
    }
    
    if ((version.warranty_years || 10) >= 20) rating += 1
    if (version.includes_battery) rating += 1
    
    return { rating: Math.min(Math.max(rating, 1), 5), suggestions }
  }

  private containsSizingKeywords(message: string): boolean {
    const keywords = ['size', 'kw', 'capacity', 'usage', 'roof', 'space', 'calculate']
    return keywords.some(keyword => message.toLowerCase().includes(keyword))
  }

  private async getSolarIrradiance(location: { state: string; postcode: string }) {
    // In a real implementation, this would call a solar irradiance API
    // For now, return average values by state
    const stateAverages: Record<string, number> = {
      'QLD': 5.2,
      'NSW': 4.9,
      'VIC': 4.2,
      'SA': 5.0,
      'WA': 5.4,
      'TAS': 3.8,
      'NT': 5.8,
      'ACT': 4.8,
    }
    
    return {
      peakSunHours: stateAverages[location.state] || 4.8,
      location: location.state,
    }
  }

  private async fetchRebateData(location: { state: string; postcode: string }) {
    // Mock rebate data - in production, this would fetch from a real API
    return [
      {
        name: 'Small-scale Renewable Energy Scheme (SRES)',
        value: '$2,000 - $4,000',
        amount: 3000,
        requirements: 'Systems under 100kW, CEC approved components',
        deadline: 'Ongoing (reduces annually)',
      },
      {
        name: `${location.state} State Solar Rebate`,
        value: '$1,000 - $2,500',
        amount: 1500,
        requirements: 'Household income under $180,000',
        deadline: 'June 30, 2025',
      },
    ]
  }

  private async getEquipmentRecommendations(
    systemSize: number,
    budget: number,
    preferences: { quality: string; features: string[] }
  ) {
    // Mock equipment data - in production, this would fetch from equipment database
    return {
      panels: [
        {
          brand: 'Jinko',
          model: 'Tiger Pro 540W',
          efficiency: 20.9,
          warranty: 25,
          pricePerPanel: 280,
        },
        {
          brand: 'LG',
          model: 'NeON R 365W',
          efficiency: 21.8,
          warranty: 25,
          pricePerPanel: 320,
        },
      ],
      inverters: [
        {
          brand: 'Fronius',
          model: 'Primo 5.0-1',
          type: 'String',
          efficiency: 97.1,
          warranty: 10,
        },
        {
          brand: 'SolarEdge',
          model: 'SE5000H',
          type: 'String with optimizers',
          efficiency: 97.3,
          warranty: 12,
        },
      ],
    }
  }
}

// Export singleton instance
export const aiAssistantService = new AIAssistantService()
```

### STEP 2: Enhanced Chat Hook
**Timeline:** Day 2 Morning
**Files:** `hooks/useAIAssistant.ts`

```typescript
// hooks/useAIAssistant.ts
import { useState, useCallback, useRef } from 'react'
import { aiAssistantService, type AIContext, type AIResponse } from '@/lib/services/aiAssistantService'
import { useAuth } from './useAuth'
import type { SolarQuote, QuoteVersion } from '@/types/database.types'

export interface ChatMessage {
  id: string
  role: 'user' | 'assistant'
  content: string
  type?: 'text' | 'calculation' | 'recommendation' | 'analysis'
  data?: any
  actions?: {
    label: string
    action: string
    parameters?: Record<string, any>
  }[]
  timestamp: Date
}

export interface UseAIAssistantOptions {
  currentQuote?: SolarQuote
  currentVersion?: QuoteVersion
  location?: {
    state: string
    postcode: string
  }
  propertyDetails?: {
    roofType: string
    roofArea: number
    shadingFactors: string[]
    energyUsage: number
  }
}

export function useAIAssistant(options: UseAIAssistantOptions = {}) {
  const { user, userType } = useAuth()
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const conversationRef = useRef<{ role: 'user' | 'assistant'; content: string }[]>([])

  // Build AI context
  const buildContext = useCallback((): AIContext => {
    return {
      userType: userType || 'homeowner',
      userId: user?.id || '',
      currentQuote: options.currentQuote,
      currentVersion: options.currentVersion,
      location: options.location,
      propertyDetails: options.propertyDetails,
    }
  }, [user, userType, options])

  // Send message to AI
  const sendMessage = useCallback(async (message: string) => {
    if (!message.trim() || isLoading) return

    setIsLoading(true)
    setError(null)

    // Add user message
    const userMessage: ChatMessage = {
      id: Date.now().toString(),
      role: 'user',
      content: message,
      timestamp: new Date(),
    }

    setMessages(prev => [...prev, userMessage])
    conversationRef.current.push({ role: 'user', content: message })

    try {
      const context = buildContext()
      const response = await aiAssistantService.chat(
        message,
        context,
        conversationRef.current.slice(-10) // Keep last 10 messages for context
      )

      // Add AI response
      const aiMessage: ChatMessage = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: response.message,
        type: response.type,
        data: response.data,
        actions: response.actions,
        timestamp: new Date(),
      }

      setMessages(prev => [...prev, aiMessage])
      conversationRef.current.push({ role: 'assistant', content: response.message })

    } catch (err) {
      setError('Failed to get AI response')
      console.error('AI chat error:', err)
    } finally {
      setIsLoading(false)
    }
  }, [isLoading, buildContext])

  // Handle action buttons
  const handleAction = useCallback(async (action: string, parameters?: Record<string, any>) => {
    setIsLoading(true)
    
    try {
      const context = buildContext()
      let response: AIResponse | null = null

      switch (action) {
        case 'calculate_system_size':
          if (options.propertyDetails && options.location) {
            response = await aiAssistantService.calculateSystemSize(
              options.propertyDetails.energyUsage,
              options.location,
              options.propertyDetails.roofArea,
              parameters?.budget
            )
          }
          break

        case 'analyze_quote':
          if (options.currentQuote) {
            const versions = parameters?.versions || []
            response = await aiAssistantService.analyzeQuote(options.currentQuote, versions)
          }
          break

        case 'show_rebates':
          if (options.location) {
            response = await aiAssistantService.getRebatesInfo(options.location)
          }
          break

        case 'recommend_equipment':
          if (parameters?.systemSize && parameters?.budget) {
            response = await aiAssistantService.recommendEquipment(
              parameters.systemSize,
              parameters.budget,
              parameters.preferences || { quality: 'tier1', features: [] }
            )
          }
          break

        default:
          console.warn('Unknown action:', action)
      }

      if (response) {
        const aiMessage: ChatMessage = {
          id: Date.now().toString(),
          role: 'assistant',
          content: response.message,
          type: response.type,
          data: response.data,
          actions: response.actions,
          timestamp: new Date(),
        }

        setMessages(prev => [...prev, aiMessage])
        conversationRef.current.push({ role: 'assistant', content: response.message })
      }
    } catch (err) {
      setError('Failed to execute action')
      console.error('Action error:', err)
    } finally {
      setIsLoading(false)
    }
  }, [buildContext, options])

  // Quick actions for common tasks
  const quickActions = [
    {
      label: 'Calculate System Size',
      action: 'calculate_system_size',
      icon: '‚ö°',
      description: 'Find the right system size for your needs',
    },
    {
      label: 'Check Rebates',
      action: 'show_rebates',
      icon: 'üí∞',
      description: 'See available rebates and incentives',
    },
    {
      label: 'Analyze Quote',
      action: 'analyze_quote',
      icon: 'üìä',
      description: 'Get detailed analysis of your quote',
    },
    {
      label: 'Equipment Guide',
      action: 'recommend_equipment',
      icon: 'üîß',
      description: 'Find the best equipment for your system',
    },
  ]

  // Clear conversation
  const clearChat = useCallback(() => {
    setMessages([])
    conversationRef.current = []
    setError(null)
  }, [])

  // Get suggested follow-up questions
  const getSuggestions = useCallback(() => {
    const lastMessage = messages[messages.length - 1]
    if (lastMessage?.role === 'assistant' && lastMessage.actions) {
      return lastMessage.actions.map(action => action.label)
    }

    // Default suggestions based on context
    const suggestions = []
    
    if (!options.currentQuote) {
      suggestions.push('How much solar do I need?', 'What rebates are available?')
    } else {
      suggestions.push('Analyze my quote', 'Compare equipment options')
    }

    return suggestions
  }, [messages, options.currentQuote])

  return {
    messages,
    isLoading,
    error,
    sendMessage,
    handleAction,
    quickActions,
    clearChat,
    getSuggestions,
    hasConversation: messages.length > 0,
  }
}
```

### STEP 3: Enhanced AI Chat Component
**Timeline:** Day 2 Afternoon to Day 3 Morning
**Files:** `components/ai/EnhancedAIChat.tsx`

```typescript
// components/ai/EnhancedAIChat.tsx
'use client'

import { useState, useRef, useEffect } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Badge } from '@/components/ui/badge'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Separator } from '@/components/ui/separator'
import { 
  Tabs, 
  TabsContent, 
  TabsList, 
  TabsTrigger 
} from '@/components/ui/tabs'
import { 
  Bot, 
  User, 
  Send, 
  Zap, 
  DollarSign, 
  BarChart3, 
  Settings,
  Lightbulb,
  Trash2,
  Copy,
} from 'lucide-react'
import { useAIAssistant, type ChatMessage } from '@/hooks/useAIAssistant'
import { useToast } from '@/components/ui/use-toast'
import { formatCurrency, formatDate } from '@/lib/utils'
import type { SolarQuote, QuoteVersion } from '@/types/database.types'

interface EnhancedAIChatProps {
  currentQuote?: SolarQuote
  currentVersion?: QuoteVersion
  location?: {
    state: string
    postcode: string
  }
  propertyDetails?: {
    roofType: string
    roofArea: number
    shadingFactors: string[]
    energyUsage: number
  }
  className?: string
}

export function EnhancedAIChat({
  currentQuote,
  currentVersion,
  location,
  propertyDetails,
  className,
}: EnhancedAIChatProps) {
  const [input, setInput] = useState('')
  const [activeTab, setActiveTab] = useState('chat')
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const { toast } = useToast()

  const {
    messages,
    isLoading,
    error,
    sendMessage,
    handleAction,
    quickActions,
    clearChat,
    getSuggestions,
    hasConversation,
  } = useAIAssistant({
    currentQuote,
    currentVersion,
    location,
    propertyDetails,
  })

  // Auto-scroll to bottom
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  const handleSend = async () => {
    if (!input.trim() || isLoading) return

    await sendMessage(input)
    setInput('')
  }

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }

  const copyMessage = async (content: string) => {
    try {
      await navigator.clipboard.writeText(content)
      toast({
        title: 'Copied',
        description: 'Message copied to clipboard',
      })
    } catch (err) {
      console.error('Copy failed:', err)
    }
  }

  return (
    <Card className={className}>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="flex items-center gap-2">
              <Bot className="h-5 w-5" />
              SolarMatch AI Assistant
            </CardTitle>
            <CardDescription>
              Get expert solar advice and analysis
            </CardDescription>
          </div>
          {hasConversation && (
            <Button
              variant="ghost"
              size="sm"
              onClick={clearChat}
              className="text-muted-foreground"
            >
              <Trash2 className="h-4 w-4" />
            </Button>
          )}
        </div>
      </CardHeader>

      <CardContent className="p-0">
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="chat">Chat</TabsTrigger>
            <TabsTrigger value="tools">Tools</TabsTrigger>
          </TabsList>

          <TabsContent value="chat" className="p-4">
            {/* Chat Messages */}
            <ScrollArea className="h-[400px] mb-4">
              <div className="space-y-4">
                {messages.length === 0 && (
                  <div className="text-center text-muted-foreground py-8">
                    <Bot className="h-12 w-12 mx-auto mb-4 opacity-50" />
                    <p className="text-lg font-medium mb-2">Hello! I'm your solar assistant</p>
                    <p className="text-sm">
                      Ask me about system sizing, equipment, rebates, or quote analysis
                    </p>
                  </div>
                )}

                {messages.map((message) => (
                  <ChatMessageComponent
                    key={message.id}
                    message={message}
                    onAction={handleAction}
                    onCopy={copyMessage}
                  />
                ))}

                {isLoading && (
                  <div className="flex items-center gap-2 text-muted-foreground">
                    <Bot className="h-4 w-4" />
                    <div className="flex space-x-1">
                      <div className="w-2 h-2 bg-current rounded-full animate-bounce" />
                      <div className="w-2 h-2 bg-current rounded-full animate-bounce" style={{ animationDelay: '0.1s' }} />
                      <div className="w-2 h-2 bg-current rounded-full animate-bounce" style={{ animationDelay: '0.2s' }} />
                    </div>
                  </div>
                )}

                <div ref={messagesEndRef} />
              </div>
            </ScrollArea>

            {/* Suggestions */}
            {!isLoading && messages.length > 0 && (
              <div className="mb-4">
                <div className="flex flex-wrap gap-2">
                  {getSuggestions().slice(0, 3).map((suggestion, index) => (
                    <Button
                      key={index}
                      variant="outline"
                      size="sm"
                      onClick={() => sendMessage(suggestion)}
                      className="text-xs"
                    >
                      <Lightbulb className="h-3 w-3 mr-1" />
                      {suggestion}
                    </Button>
                  ))}
                </div>
              </div>
            )}

            {/* Input */}
            <div className="flex gap-2">
              <Input
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Ask me about solar systems, rebates, or equipment..."
                disabled={isLoading}
                className="flex-1"
              />
              <Button 
                onClick={handleSend} 
                disabled={!input.trim() || isLoading}
                size="sm"
              >
                <Send className="h-4 w-4" />
              </Button>
            </div>

            {error && (
              <p className="text-sm text-destructive mt-2">{error}</p>
            )}
          </TabsContent>

          <TabsContent value="tools" className="p-4">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              {quickActions.map((action) => (
                <Button
                  key={action.action}
                  variant="outline"
                  className="h-auto p-4 flex flex-col items-start gap-2"
                  onClick={() => handleAction(action.action)}
                  disabled={isLoading}
                >
                  <div className="flex items-center gap-2 w-full">
                    <span className="text-lg">{action.icon}</span>
                    <span className="font-medium">{action.label}</span>
                  </div>
                  <p className="text-xs text-muted-foreground text-left">
                    {action.description}
                  </p>
                </Button>
              ))}
            </div>

            {/* Context Information */}
            <Separator className="my-6" />
            <div className="space-y-4">
              <h3 className="font-medium">Current Context</h3>
              <div className="grid grid-cols-2 gap-4 text-sm">
                {location && (
                  <div>
                    <span className="text-muted-foreground">Location:</span>
                    <p>{location.state}, {location.postcode}</p>
                  </div>
                )}
                {currentQuote && (
                  <div>
                    <span className="text-muted-foreground">Quote:</span>
                    <p>{currentQuote.system_size}kW System</p>
                  </div>
                )}
                {propertyDetails && (
                  <div>
                    <span className="text-muted-foreground">Energy Usage:</span>
                    <p>{propertyDetails.energyUsage}kWh/year</p>
                  </div>
                )}
                {currentVersion && (
                  <div>
                    <span className="text-muted-foreground">Quote Version:</span>
                    <p>v{currentVersion.version_number}</p>
                  </div>
                )}
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  )
}

function ChatMessageComponent({
  message,
  onAction,
  onCopy,
}: {
  message: ChatMessage
  onAction: (action: string, parameters?: any) => void
  onCopy: (content: string) => void
}) {
  const isUser = message.role === 'user'

  return (
    <div className={`flex gap-3 ${isUser ? 'justify-end' : 'justify-start'}`}>
      {!isUser && (
        <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center shrink-0">
          <Bot className="h-4 w-4" />
        </div>
      )}

      <div className={`max-w-[80%] space-y-2 ${isUser ? 'items-end' : 'items-start'}`}>
        <div className={`rounded-lg px-3 py-2 ${
          isUser 
            ? 'bg-primary text-primary-foreground' 
            : 'bg-muted'
        }`}>
          <div className="whitespace-pre-wrap text-sm">
            {message.content}
          </div>

          {/* Message type indicator */}
          {message.type && message.type !== 'text' && (
            <Badge variant="outline" className="mt-2 text-xs">
              {message.type}
            </Badge>
          )}

          {/* Structured data display */}
          {message.data && message.type === 'calculation' && (
            <div className="mt-3 p-3 bg-background/50 rounded border">
              <div className="grid grid-cols-2 gap-2 text-xs">
                {Object.entries(message.data).map(([key, value]) => (
                  <div key={key}>
                    <span className="text-muted-foreground capitalize">
                      {key.replace(/([A-Z])/g, ' $1').toLowerCase()}:
                    </span>
                    <p className="font-medium">
                      {typeof value === 'number' && key.includes('cost') 
                        ? formatCurrency(value * 100)
                        : String(value)
                      }
                    </p>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Action buttons */}
        {message.actions && message.actions.length > 0 && (
          <div className="flex flex-wrap gap-2">
            {message.actions.map((action, index) => (
              <Button
                key={index}
                variant="outline"
                size="sm"
                onClick={() => onAction(action.action, action.parameters)}
                className="text-xs"
              >
                {action.label}
              </Button>
            ))}
          </div>
        )}

        {/* Message meta */}
        <div className="flex items-center gap-2 text-xs text-muted-foreground">
          <span>{formatDate(message.timestamp)}</span>
          <Button
            variant="ghost"
            size="sm"
            className="h-auto p-0 text-xs"
            onClick={() => onCopy(message.content)}
          >
            <Copy className="h-3 w-3" />
          </Button>
        </div>
      </div>

      {isUser && (
        <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center shrink-0">
          <User className="h-4 w-4" />
        </div>
      )}
    </div>
  )
}
```

### STEP 4: API Routes for AI Features
**Timeline:** Day 3 Afternoon
**Files:** Multiple API routes

**AI Chat API:**
```typescript
// app/api/ai/chat/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase'
import { aiAssistantService } from '@/lib/services/aiAssistantService'
import { z } from 'zod'

const chatSchema = z.object({
  message: z.string().min(1).max(1000),
  context: z.object({
    userType: z.enum(['homeowner', 'installer', 'admin']),
    currentQuote: z.object({
      id: z.string(),
      system_size: z.number(),
      annual_usage: z.number().optional(),
      property_address: z.string(),
    }).optional(),
    location: z.object({
      state: z.string(),
      postcode: z.string(),
    }).optional(),
    propertyDetails: z.object({
      roofArea: z.number(),
      energyUsage: z.number(),
      roofType: z.string(),
      shadingFactors: z.array(z.string()),
    }).optional(),
  }),
  conversationHistory: z.array(z.object({
    role: z.enum(['user', 'assistant']),
    content: z.string(),
  })).optional(),
})

export async function POST(request: NextRequest) {
  try {
    const supabase = createClient()
    
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Validate request body
    const body = await request.json()
    const { message, context, conversationHistory = [] } = chatSchema.parse(body)

    // Add user ID to context
    const aiContext = {
      ...context,
      userId: user.id,
    }

    // Get AI response
    const response = await aiAssistantService.chat(
      message,
      aiContext,
      conversationHistory
    )

    // Log the interaction
    await supabase.rpc('log_event', {
      p_category: 'ai',
      p_event_type: 'chat_interaction',
      p_message: 'AI chat interaction',
      p_severity: 'info',
      p_user_id: user.id,
      p_details: {
        messageLength: message.length,
        responseType: response.type,
        hasActions: (response.actions || []).length > 0,
      },
    })

    return NextResponse.json(response)
  } catch (error) {
    console.error('AI chat error:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.errors },
        { status: 400 }
      )
    }
    
    return NextResponse.json(
      { error: 'AI service unavailable' },
      { status: 500 }
    )
  }
}
```

**System Sizing API:**
```typescript
// app/api/ai/calculate-size/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase'
import { aiAssistantService } from '@/lib/services/aiAssistantService'
import { z } from 'zod'

const sizingSchema = z.object({
  energyUsage: z.number().positive(),
  location: z.object({
    state: z.string(),
    postcode: z.string(),
  }),
  roofSpace: z.number().positive(),
  budget: z.number().positive().optional(),
})

export async function POST(request: NextRequest) {
  try {
    const supabase = createClient()
    
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Validate request body
    const body = await request.json()
    const { energyUsage, location, roofSpace, budget } = sizingSchema.parse(body)

    // Calculate system size
    const response = await aiAssistantService.calculateSystemSize(
      energyUsage,
      location,
      roofSpace,
      budget
    )

    return NextResponse.json(response)
  } catch (error) {
    console.error('System sizing error:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data' },
        { status: 400 }
      )
    }
    
    return NextResponse.json(
      { error: 'Failed to calculate system size' },
      { status: 500 }
    )
  }
}
```

---

## ‚úÖ VERIFICATION CHECKLIST

### AI Integration:
- [ ] DeepSeek API integration working
- [ ] Context-aware responses generated
- [ ] Solar knowledge base accessible
- [ ] Calculations accurate for Australian conditions

### Chat Functionality:
- [ ] Real-time chat interface responsive
- [ ] Action buttons trigger correct functions
- [ ] Message history persists correctly
- [ ] Error handling provides clear feedback

### Solar Expertise:
- [ ] System sizing calculations accurate
- [ ] Equipment recommendations relevant
- [ ] Rebate information up-to-date
- [ ] Quote analysis provides valuable insights

### User Experience:
- [ ] Quick actions easily accessible
- [ ] Chat interface intuitive
- [ ] Responses formatted clearly
- [ ] Context information displayed helpfully

---

## üö® PRODUCTION CONSIDERATIONS

### API Rate Limiting:
- Monitor DeepSeek API usage and costs
- Implement caching for common queries
- Add user rate limiting to prevent abuse

### Data Privacy:
- Ensure no sensitive data sent to external APIs
- Implement conversation data retention policies
- Add opt-out options for AI features

### Performance:
- Cache common responses (equipment data, rebates)
- Optimize system calculations
- Monitor response times

---

## üìà NEXT STEPS

After completing this execution plan:
1. Test AI responses for accuracy and relevance
2. Train AI with more Australian solar data
3. Implement voice chat capabilities
4. Add multilingual support
5. Proceed to Admin Panel Development phase
