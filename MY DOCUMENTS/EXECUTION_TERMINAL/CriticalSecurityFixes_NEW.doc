# CRITICAL SECURITY FIXES - DEVELOPER EXECUTION SCRIPT
**Generated:** August 4, 2025  
**Priority:** IMMEDIATE - EXECUTE FIRST  
**Dependencies:** None (this is the foundation)

---

## ðŸ“‹ EXECUTION OVERVIEW

**Objective:** Fix critical security vulnerabilities and implement secure server-side business logic
**Estimated Time:** 2-3 days
**Risk Level:** CRITICAL (Must be completed before any other execution plans)

**DEVELOPER ACTIONS:** This script will guide you to:
1. Remove hardcoded API keys from client-side code
2. Create secure server-side API routes
3. Implement proper authentication middleware
4. Set up environment variables correctly
5. Add input validation and rate limiting

---

## ðŸš¨ CRITICAL SECURITY VULNERABILITIES IDENTIFIED

**VULNERABILITY 1: HARDCODED API KEY EXPOSURE**
- **Location:** `hooks/useDeepseekAPI.ts` line 10
- **Code:** `const DEEPSEEK_API_KEY = 'sk-dc7a57ea9f5548c89c801208e4dbc112';`
- **Risk:** Client-side exposure of paid API key ($1000+ monthly billing exposure)
- **Action Required:** IMMEDIATE removal and server-side implementation

**VULNERABILITY 2: MISSING AUTHENTICATION ON API ROUTES**
- **Risk:** Unauthorized access to sensitive operations
- **Action Required:** Implement authentication middleware on all protected routes

**VULNERABILITY 3: NO INPUT VALIDATION**
- **Risk:** SQL injection, XSS attacks, data corruption
- **Action Required:** Add comprehensive input validation

---

## ðŸ”§ DEVELOPER EXECUTION STEPS

### STEP 1: Environment Variables Setup
**DEVELOPER ACTION:** Create or update the `.env.local` file in the project root

**File Path:** `.env.local`
**Command:** Create/modify this file with the following content:

```bash
# AI Service Configuration
DEEPSEEK_API_KEY=sk-dc7a57ea9f5548c89c801208e4dbc112

# Supabase Configuration  
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url_here
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here
SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key_here

# Authentication
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your_nextauth_secret_here

# Rate Limiting (Optional)
UPSTASH_REDIS_REST_URL=your_redis_url_here
UPSTASH_REDIS_REST_TOKEN=your_redis_token_here
```

**VERIFICATION:** Run `npm run build` - should complete without environment variable errors

**STOP & CONFIRM:** Test that environment variables are loaded correctly before proceeding.

---

### STEP 2: Install Required Dependencies
**DEVELOPER ACTION:** Install security and validation packages

**Command:** Run these npm install commands:

```bash
npm install zod @supabase/ssr
npm install --save-dev @types/node
```

**VERIFICATION:** Check `package.json` for the new dependencies

---

### STEP 3: Create Secure Server-Side AI API Route
**DEVELOPER ACTION:** Create the secure AI chat API endpoint

**File Path:** `app/api/ai/chat/route.ts`
**Command:** Create this file with the complete implementation:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase'
import { z } from 'zod'

// Input validation schema
const chatRequestSchema = z.object({
  message: z.string().min(1).max(1000),
  context: z.object({
    quoteId: z.string().optional(),
    systemSize: z.number().optional(),
    propertyType: z.string().optional(),
  }).optional(),
})

// Rate limiting map (in production, use Redis)
const rateLimitMap = new Map<string, { count: number; resetTime: number }>()

const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY!
const DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions'

export async function POST(request: NextRequest) {
  try {
    // 1. Authentication check
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      )
    }

    // 2. Rate limiting check
    const userKey = user.id
    const now = Date.now()
    const windowMs = 60 * 1000 // 1 minute
    const maxRequests = 10 // 10 requests per minute

    const userLimit = rateLimitMap.get(userKey)
    if (userLimit) {
      if (now < userLimit.resetTime) {
        if (userLimit.count >= maxRequests) {
          return NextResponse.json(
            { error: 'Rate limit exceeded. Try again later.' },
            { status: 429 }
          )
        }
        userLimit.count++
      } else {
        rateLimitMap.set(userKey, { count: 1, resetTime: now + windowMs })
      }
    } else {
      rateLimitMap.set(userKey, { count: 1, resetTime: now + windowMs })
    }

    // 3. Input validation
    const body = await request.json()
    const validatedData = chatRequestSchema.parse(body)

    // 4. Prepare AI request
    const aiRequest = {
      model: 'deepseek-chat',
      messages: [
        {
          role: 'system',
          content: 'You are a helpful solar energy assistant for Australian customers. Provide accurate information about solar panels, installation, rebates, and energy savings.'
        },
        {
          role: 'user',
          content: validatedData.message
        }
      ],
      max_tokens: 500,
      temperature: 0.7,
    }

    // 5. Call DeepSeek API
    const aiResponse = await fetch(DEEPSEEK_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
      },
      body: JSON.stringify(aiRequest),
    })

    if (!aiResponse.ok) {
      throw new Error(`AI API error: ${aiResponse.status}`)
    }

    const aiData = await aiResponse.json()

    // 6. Log the interaction (optional - depends on database schema)
    try {
      await supabase.from('ai_interactions').insert({
        user_id: user.id,
        message: validatedData.message,
        response: aiData.choices[0].message.content,
        context: validatedData.context,
        created_at: new Date().toISOString(),
      })
    } catch (logError) {
      console.warn('Failed to log AI interaction:', logError)
      // Don't fail the request if logging fails
    }

    // 7. Return response
    return NextResponse.json({
      message: aiData.choices[0].message.content,
      usage: aiData.usage,
    })

  } catch (error) {
    console.error('AI chat error:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid input data', details: error.errors },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// Handle preflight requests
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}
```

**VERIFICATION:** Test the API endpoint:
```bash
curl -X POST http://localhost:3000/api/ai/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "Hello, test message"}'
```

**STOP & CONFIRM:** Verify the API route returns a 401 error (authentication required) before proceeding.

---

### STEP 4: Fix Client-Side Hook to Use Secure API
**DEVELOPER ACTION:** Update the client-side hook to use the secure server-side API

**File Path:** `hooks/useDeepseekAPI.ts`
**Command:** Replace the entire file content with:

```typescript
'use client'

import { useState, useCallback } from 'react'
import { useAuth } from './useAuth'

interface ChatMessage {
  role: 'user' | 'assistant'
  content: string
}

interface ChatContext {
  quoteId?: string
  systemSize?: number
  propertyType?: string
}

export function useDeepseekAPI() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const { user } = useAuth()

  const sendMessage = useCallback(async (
    message: string, 
    context?: ChatContext
  ): Promise<string | null> => {
    if (!user) {
      setError('Authentication required')
      return null
    }

    setIsLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/ai/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message,
          context,
        }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to get AI response')
      }

      return data.message
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error'
      setError(errorMessage)
      return null
    } finally {
      setIsLoading(false)
    }
  }, [user])

  return {
    sendMessage,
    isLoading,
    error,
  }
}
```

**VERIFICATION:** Check that the hardcoded API key is completely removed from the file.

---

### STEP 5: Create Input Validation Schemas
**DEVELOPER ACTION:** Create comprehensive validation schemas

**File Path:** `lib/validation/schemas.ts`
**Command:** Create this file:

```typescript
import { z } from 'zod'

// Australian postcode validation
const AustralianPostcodeSchema = z.string().regex(/^[0-9]{4}$/, 'Must be a valid 4-digit postcode')

// Australian phone number validation  
const AustralianPhoneSchema = z.string().regex(/^(\+61|0)[0-9]{9}$/, 'Must be a valid Australian phone number')

// Quote request validation
export const QuoteRequestSchema = z.object({
  fullName: z.string().min(2, 'Name must be at least 2 characters').max(100, 'Name too long'),
  email: z.string().email('Invalid email address'),
  phone: AustralianPhoneSchema.optional(),
  propertyAddress: z.string().min(10, 'Address must be at least 10 characters').max(200, 'Address too long'),
  postcode: AustralianPostcodeSchema,
  state: z.enum(['NSW', 'VIC', 'QLD', 'SA', 'WA', 'TAS', 'NT', 'ACT'], {
    errorMap: () => ({ message: 'Must select a valid Australian state' })
  }),
  propertyType: z.enum(['house', 'apartment', 'townhouse', 'commercial'], {
    errorMap: () => ({ message: 'Must select a valid property type' })
  }),
  roofType: z.enum(['tile', 'metal', 'flat', 'colorbond', 'concrete'], {
    errorMap: () => ({ message: 'Must select a valid roof type' })
  }).optional(),
  annualUsage: z.number().min(1000, 'Annual usage must be at least 1000 kWh').max(50000, 'Annual usage seems too high').optional(),
  budgetRange: z.enum(['5000-10000', '10000-15000', '15000-20000', '20000-25000', '25000+'], {
    errorMap: () => ({ message: 'Must select a valid budget range' })
  }).optional(),
})

// User registration validation
export const UserRegistrationSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Password must contain uppercase, lowercase, and number'),
  fullName: z.string().min(2, 'Name must be at least 2 characters').max(100, 'Name too long'),
  phone: AustralianPhoneSchema.optional(),
  userType: z.enum(['homeowner', 'installer'], {
    errorMap: () => ({ message: 'Must select either homeowner or installer' })
  }),
})

// Installer registration validation
export const InstallerRegistrationSchema = UserRegistrationSchema.extend({
  companyName: z.string().min(2, 'Company name must be at least 2 characters').max(100, 'Company name too long'),
  abn: z.string().regex(/^[0-9]{11}$/, 'ABN must be 11 digits'),
  certificationLevel: z.enum(['CEC', 'CleanEnergyCouncil', 'Other'], {
    errorMap: () => ({ message: 'Must select a valid certification' })
  }),
  serviceAreas: z.array(z.string()).min(1, 'Must select at least one service area'),
})

// Chat message validation
export const ChatMessageSchema = z.object({
  message: z.string().min(1, 'Message cannot be empty').max(1000, 'Message too long'),
  context: z.object({
    quoteId: z.string().uuid().optional(),
    systemSize: z.number().positive().optional(),
    propertyType: z.string().optional(),
  }).optional(),
})

// Bid submission validation
export const BidSubmissionSchema = z.object({
  quoteId: z.string().uuid('Invalid quote ID'),
  totalCost: z.number().min(1000, 'Cost must be at least $1,000').max(100000, 'Cost seems too high'),
  systemSize: z.number().min(1, 'System size must be at least 1kW').max(50, 'System size seems too large'),
  panelBrand: z.string().min(2, 'Panel brand required').max(50, 'Panel brand too long'),
  inverterBrand: z.string().min(2, 'Inverter brand required').max(50, 'Inverter brand too long'),
  warrantyYears: z.number().min(5, 'Warranty must be at least 5 years').max(30, 'Warranty period too long'),
  installationTimeWeeks: z.number().min(1, 'Installation time must be at least 1 week').max(20, 'Installation time too long'),
  description: z.string().max(1000, 'Description too long').optional(),
})
```

**VERIFICATION:** Import the schemas in a test file to check for syntax errors.

---

### STEP 6: Create Secure Authentication Middleware
**DEVELOPER ACTION:** Create middleware for protected routes

**File Path:** `lib/middleware/auth.ts`
**Command:** Create this file:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase'

export async function withAuth(
  request: NextRequest,
  handler: (request: NextRequest, user: any) => Promise<NextResponse>
) {
  try {
    const supabase = createClient()
    const { data: { user }, error } = await supabase.auth.getUser()

    if (error || !user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      )
    }

    return handler(request, user)
  } catch (error) {
    console.error('Auth middleware error:', error)
    return NextResponse.json(
      { error: 'Authentication error' },
      { status: 500 }
    )
  }
}

export async function withRoleAuth(
  request: NextRequest,
  allowedRoles: string[],
  handler: (request: NextRequest, user: any) => Promise<NextResponse>
) {
  try {
    const supabase = createClient()
    const { data: { user }, error } = await supabase.auth.getUser()

    if (error || !user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      )
    }

    // Get user profile to check role
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (!profile || !allowedRoles.includes(profile.role)) {
      return NextResponse.json(
        { error: 'Insufficient permissions' },
        { status: 403 }
      )
    }

    return handler(request, user)
  } catch (error) {
    console.error('Role auth middleware error:', error)
    return NextResponse.json(
      { error: 'Authorization error' },
      { status: 500 }
    )
  }
}
```

---

### STEP 7: Create Rate Limiting Utility
**DEVELOPER ACTION:** Create rate limiting for API protection

**File Path:** `lib/utils/rateLimit.ts`
**Command:** Create this file:

```typescript
// Simple in-memory rate limiting (use Redis in production)
const rateLimitMap = new Map<string, { count: number; resetTime: number }>()

export interface RateLimitOptions {
  maxRequests: number
  windowMs: number
  keyGenerator?: (identifier: string) => string
}

export function rateLimit(
  identifier: string,
  options: RateLimitOptions = { maxRequests: 10, windowMs: 60000 }
): { allowed: boolean; remaining: number; resetTime: number } {
  const now = Date.now()
  const key = options.keyGenerator ? options.keyGenerator(identifier) : identifier
  
  const record = rateLimitMap.get(key)
  
  if (!record || now > record.resetTime) {
    // Create new record or reset expired record
    const newRecord = {
      count: 1,
      resetTime: now + options.windowMs
    }
    rateLimitMap.set(key, newRecord)
    
    return {
      allowed: true,
      remaining: options.maxRequests - 1,
      resetTime: newRecord.resetTime
    }
  }
  
  if (record.count >= options.maxRequests) {
    return {
      allowed: false,
      remaining: 0,
      resetTime: record.resetTime
    }
  }
  
  record.count++
  rateLimitMap.set(key, record)
  
  return {
    allowed: true,
    remaining: options.maxRequests - record.count,
    resetTime: record.resetTime
  }
}

// Clean up expired entries periodically
setInterval(() => {
  const now = Date.now()
  for (const [key, record] of rateLimitMap.entries()) {
    if (now > record.resetTime) {
      rateLimitMap.delete(key)
    }
  }
}, 60000) // Clean up every minute
```

---

### STEP 8: Create Secure User Registration API
**DEVELOPER ACTION:** Create a secure registration endpoint

**File Path:** `app/api/auth/register/route.ts`
**Command:** Create this file:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase'
import { UserRegistrationSchema, InstallerRegistrationSchema } from '@/lib/validation/schemas'
import { rateLimit } from '@/lib/utils/rateLimit'
import { z } from 'zod'

export async function POST(request: NextRequest) {
  try {
    // Rate limiting
    const ip = request.headers.get('x-forwarded-for') || 'unknown'
    const rateLimitCheck = rateLimit(`register:${ip}`, { maxRequests: 3, windowMs: 900000 }) // 3 per 15 minutes
    
    if (!rateLimitCheck.allowed) {
      return NextResponse.json(
        { error: 'Too many registration attempts. Please try again later.' },
        { status: 429 }
      )
    }

    const body = await request.json()
    
    // Validate based on user type
    let validatedData
    if (body.userType === 'installer') {
      validatedData = InstallerRegistrationSchema.parse(body)
    } else {
      validatedData = UserRegistrationSchema.parse(body)
    }

    const supabase = createClient()

    // Check if email already exists
    const { data: existingUser } = await supabase
      .from('profiles')
      .select('email')
      .eq('email', validatedData.email)
      .single()

    if (existingUser) {
      return NextResponse.json(
        { error: 'Email address already registered' },
        { status: 400 }
      )
    }

    // Create user in Supabase Auth
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email: validatedData.email,
      password: validatedData.password,
      options: {
        data: {
          full_name: validatedData.fullName,
          user_type: validatedData.userType,
        }
      }
    })

    if (authError) {
      console.error('Auth signup error:', authError)
      return NextResponse.json(
        { error: authError.message || 'Registration failed' },
        { status: 400 }
      )
    }

    // Create profile record
    if (authData.user) {
      const profileData = {
        id: authData.user.id,
        email: validatedData.email,
        full_name: validatedData.fullName,
        phone: validatedData.phone || null,
        role: validatedData.userType,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      }

      const { error: profileError } = await supabase
        .from('profiles')
        .insert([profileData])

      if (profileError) {
        console.error('Profile creation error:', profileError)
        // Clean up auth user if profile creation fails
        await supabase.auth.admin.deleteUser(authData.user.id)
        return NextResponse.json(
          { error: 'Failed to create user profile' },
          { status: 500 }
        )
      }

      // Create installer profile if user is installer
      if (validatedData.userType === 'installer' && 'companyName' in validatedData) {
        const installerData = {
          user_id: authData.user.id,
          company_name: validatedData.companyName,
          abn: validatedData.abn,
          certification_level: validatedData.certificationLevel,
          service_areas: validatedData.serviceAreas,
          verification_status: 'pending',
          created_at: new Date().toISOString(),
        }

        const { error: installerError } = await supabase
          .from('installer_profiles')
          .insert([installerData])

        if (installerError) {
          console.error('Installer profile creation error:', installerError)
          // Don't fail the registration, but log the error
        }
      }
    }

    return NextResponse.json({
      success: true,
      message: 'Registration successful. Please check your email to verify your account.',
      user: {
        id: authData.user?.id,
        email: authData.user?.email,
        userType: validatedData.userType,
      }
    })

  } catch (error) {
    console.error('Registration error:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation failed',
          details: error.errors.map(err => ({
            field: err.path.join('.'),
            message: err.message
          }))
        },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { error: 'Registration failed. Please try again.' },
      { status: 500 }
    )
  }
}
```

**VERIFICATION:** Test the registration endpoint:
```bash
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "TestPass123",
    "fullName": "Test User",
    "userType": "homeowner"
  }'
```

---

## âœ… VERIFICATION CHECKLIST

### Critical Security Fixes:
- [ ] DEEPSEEK_API_KEY completely removed from client-side code
- [ ] API key moved to server-side environment variable
- [ ] All sensitive API routes require authentication
- [ ] Input validation implemented with Zod schemas
- [ ] Rate limiting applied to registration and AI endpoints
- [ ] Error messages don't expose sensitive information

### Functionality Verification:
- [ ] AI chat works through new secure API route
- [ ] User registration works with validation
- [ ] Rate limits prevent abuse
- [ ] Authentication middleware blocks unauthorized access
- [ ] Environment variables load correctly

### Testing Commands:
```bash
# Test environment variables
npm run build

# Test AI chat endpoint (should require auth)
curl -X POST http://localhost:3000/api/ai/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "Hello"}'

# Should return 401 Unauthorized

# Test registration endpoint
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "TestPass123",
    "fullName": "Test User",
    "userType": "homeowner"
  }'

# Test rate limiting (run 15 times rapidly)
for i in {1..15}; do
  curl -X POST http://localhost:3000/api/auth/register \
    -H "Content-Type: application/json" \
    -d '{"email": "test'$i'@example.com", "password": "TestPass123", "fullName": "Test User", "userType": "homeowner"}'
done
```

**STOP & CONFIRM:** All tests pass and security vulnerabilities are eliminated before proceeding to the next execution plan.

---

## ðŸ”’ SECURITY MEASURES IMPLEMENTED

1. **API Key Protection:** Moved to server-side environment variables
2. **Input Validation:** Comprehensive Zod schemas for all user inputs
3. **Rate Limiting:** Prevents API abuse and DoS attacks
4. **Authentication Middleware:** All sensitive endpoints require valid session
5. **Role-Based Access:** Different permissions for homeowners, installers, admins
6. **Error Handling:** Generic error messages prevent information leakage
7. **CORS Protection:** Proper CORS headers on API routes
8. **SQL Injection Prevention:** Using Supabase parameterized queries
9. **Password Security:** Strong password requirements with regex validation
10. **Email Verification:** Registration requires email confirmation

---

## ðŸ“ˆ NEXT STEPS

**DEPENDENCY CHECK:** Before proceeding to DatabaseSchemaImplementation.doc:
- Confirm all security fixes are implemented and tested
- Verify environment variables are properly configured
- Ensure authentication system is working
- Test all validation schemas

**This execution plan must be 100% complete before proceeding to any other execution plan.**
